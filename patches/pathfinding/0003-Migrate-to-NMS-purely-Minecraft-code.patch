From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Abel <abelvanhulst@gmail.com>
Date: Mon, 16 Dec 2024 21:02:40 +0100
Subject: [PATCH] Migrate to NMS/purely Minecraft code


diff --git a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStar.java b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStar.java
index 473c6befdf1f9fb1dfe69bdd2822dd9fbd4b7432..0304258440e2b5b1a9a43a5895d184f07c438d87 100644
--- a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStar.java
+++ b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStar.java
@@ -19,10 +19,9 @@
 package nl.abelkrijgtalles.mojangmaps.pathfinding;
 
 import java.util.ArrayList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.Material;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.Vec3;
+import nl.abelkrijgtalles.mojangmaps.pathfinding.platform.Location;
 
 public class AStar {
 
@@ -87,9 +86,6 @@ public class AStar {
                 pathFound = true;
                 endNode = n;
 
-                // print information about last node
-                Bukkit.broadcastMessage(uncheckedNodes.size() + "uc " + checkedNodes.size() + "c " + round(n.expense) + "cne " + round(n.getEstimatedFinalExpense()) + "cnee ");
-
                 break;
             }
 
@@ -100,9 +96,6 @@ public class AStar {
 
         // returning if no path has been found
         if (!pathFound) {
-            float duration = (System.nanoTime() - nsStart) / 1000000f;
-            Bukkit.broadcastMessage("A* took " + (duration > 50 ? ChatColor.RED : ChatColor.WHITE) + duration + "ms" + ChatColor.WHITE + " to not find a path.");
-
             return new Location[0];
         }
 
@@ -125,10 +118,6 @@ public class AStar {
 
         locations[0] = startNode.getLocation();
 
-        // outputting benchmark result
-        float duration = (System.nanoTime() - nsStart) / 1000000f;
-        Bukkit.broadcastMessage("A* took " + (duration > 50 ? ChatColor.RED : ChatColor.WHITE) + duration + "ms" + ChatColor.WHITE + " to find a path.");
-
         return locations;
     }
 
@@ -149,7 +138,7 @@ public class AStar {
 
     public boolean isObstructed(Location loc) {
 
-        if (loc.getBlock().getType().isSolid())
+        if (loc.isSolidBlock())
             return true;
 
         return false;
@@ -166,7 +155,7 @@ public class AStar {
 
     public double distanceTo(Location loc1, Location loc2) {
 
-        if (loc1.getWorld() != loc2.getWorld())
+        if (loc1.getLevel() != loc2.getLevel())
             return Double.MAX_VALUE;
 
         double deltaX = Math.abs(loc1.getX() - loc2.getX());
@@ -240,7 +229,7 @@ public class AStar {
             for (int x = -1; x <= 1; x++)
                 for (int z = -1; z <= 1; z++)
                     if (!(x == 0 && z == 0) && x * z == 0) {
-                        Location loc = new Location(Bukkit.getWorlds().get(0), location.getBlockX() + x, location.getBlockY(), location.getBlockZ() + z);
+                        Location loc = new Location(new Vec3(location.getBlockX() + x, location.getBlockY(), location.getBlockZ() + z), location.getLevel());
 
                         // usual unchanged y
                         if (canStandAt(loc))
@@ -277,10 +266,10 @@ public class AStar {
 
                         //ladder
                         if (canClimbLadders)
-                            if (loc.clone().add(-x, 0, -z).getBlock().getType() == Material.LADDER) {
+                            if (loc.clone().add(-x, 0, -z).isTheSameBlock(Blocks.LADDER)) {
                                 Location nLoc = loc.clone().add(-x, 0, -z);
                                 int up = 1;
-                                while (nLoc.clone().add(0, up, 0).getBlock().getType() == Material.LADDER)
+                                while (nLoc.clone().add(0, up, 0).isTheSameBlock(Blocks.LADDER))
                                     up++;
 
                                 reachNode(nLoc.clone().add(0, up, 0), expense + up * 2);
diff --git a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStarRaw.java b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStarRaw.java
index 2df4ceac4424d18ef9452ed160deb558287549ae..df9c3ed069151ebdce2bf568181eece0ee4a1de9 100644
--- a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStarRaw.java
+++ b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/AStarRaw.java
@@ -18,10 +18,9 @@
 
 package nl.abelkrijgtalles.mojangmaps.pathfinding;
 
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.Material;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.abelkrijgtalles.mojangmaps.pathfinding.platform.Location;
 
 public class AStarRaw {
 
@@ -36,7 +35,7 @@ public class AStarRaw {
     private int baseZ;
 
     private boolean pathFound = false;
-    private Material[][][] materials = new Material[maxNodeTests * 2][maxNodeTests * 2][maxNodeTests * 2];
+    private BlockState[][][] materials = new BlockState[maxNodeTests * 2][maxNodeTests * 2][maxNodeTests * 2];
     private byte[][][] walkability = new byte[maxNodeTests * 2][maxNodeTests * 2][maxNodeTests * 2];
     //  1 walkable
     //  0 untested
@@ -76,14 +75,6 @@ public class AStarRaw {
         if (!canStandAt(baseX, baseY, baseZ) || !canStandAt(endLocation.getBlockX(), endLocation.getBlockY(), endLocation.getBlockZ()))
             return new Location[0];
 
-        // time for benchmark
-        long nsStart = System.nanoTime();
-
-
-        // outputting benchmark result
-        float duration = (System.nanoTime() - nsStart) / 1000000f;
-        Bukkit.broadcastMessage("A* took " + (duration > 50 ? ChatColor.RED : ChatColor.WHITE) + duration + "ms" + ChatColor.WHITE + " to find a path.");
-
         return new Location[0]; // TODO
     }
 
@@ -91,20 +82,20 @@ public class AStarRaw {
     // CHECKS
     // ---
 
-    private Material getMaterial(int relX, int relY, int relZ) {
+    private BlockState getMaterial(int relX, int relY, int relZ) {
 
         if (materials[relX][relY][relZ] != null)
             return materials[relX][relY][relZ];
 
-        Material mat = startLocation.getWorld().getBlockAt(baseX + relX, baseY + relY, baseZ + relZ).getType();
+        BlockState mat = startLocation.getBLockState();
         materials[relX][relY][relZ] = mat;
 
         return mat;
     }
 
-    private boolean canWalkThrough(Material mat) {
+    private boolean canWalkThrough(BlockState mat) {
 
-        return !mat.isSolid();
+        return !Block.isShapeFullBlock(mat.getOcclusionShape());
     }
 
 
@@ -139,7 +130,7 @@ public class AStarRaw {
 
     public double distanceTo(Location loc1, Location loc2) {
 
-        if (loc1.getWorld() != loc2.getWorld())
+        if (loc1.getLevel() != loc2.getLevel())
             return Double.MAX_VALUE;
 
         double deltaX = Math.abs(loc1.getX() - loc2.getX());
diff --git a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/JPS.java b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/JPS.java
index a2e3ec2792228a81a872f532189923ffb690b52f..d7e987438bee385ad054b94490da59a3f4c30521 100644
--- a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/JPS.java
+++ b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/JPS.java
@@ -19,10 +19,9 @@
 package nl.abelkrijgtalles.mojangmaps.pathfinding;
 
 import java.util.ArrayList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.Material;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.Vec3;
+import nl.abelkrijgtalles.mojangmaps.pathfinding.platform.Location;
 
 public class JPS {
 
@@ -71,9 +70,6 @@ public class JPS {
         if (!(canStandAt(startLocation) && canStandAt(endLocation)))
             return new Location[0];
 
-        // time for benchmark
-        long nsStart = System.nanoTime();
-
         uncheckedNodes.add(startNode);
 
         // cycle through untested nodes until a exit condition is fulfilled
@@ -87,9 +83,6 @@ public class JPS {
                 pathFound = true;
                 endNode = n;
 
-                // print information about last node
-                Bukkit.broadcastMessage(uncheckedNodes.size() + "uc " + checkedNodes.size() + "c " + round(n.expense) + "cne " + round(n.getEstimatedFinalExpense()) + "cnee ");
-
                 break;
             }
 
@@ -100,8 +93,6 @@ public class JPS {
 
         // returning if no path has been found
         if (!pathFound) {
-            float duration = (System.nanoTime() - nsStart) / 1000000f;
-            Bukkit.broadcastMessage("A* took " + (duration > 50 ? ChatColor.RED : ChatColor.WHITE) + duration + "ms" + ChatColor.WHITE + " to not find a path.");
 
             return new Location[0];
         }
@@ -125,10 +116,6 @@ public class JPS {
 
         locations[0] = startNode.getLocation();
 
-        // outputting benchmark result
-        float duration = (System.nanoTime() - nsStart) / 1000000f;
-        Bukkit.broadcastMessage("A* took " + (duration > 50 ? ChatColor.RED : ChatColor.WHITE) + duration + "ms" + ChatColor.WHITE + " to find a path.");
-
         return locations;
     }
 
@@ -149,7 +136,7 @@ public class JPS {
 
     public boolean isObstructed(Location loc) {
 
-        if (loc.getBlock().getType().isSolid())
+        if (loc.isSolidBlock())
             return true;
 
         return false;
@@ -166,7 +153,7 @@ public class JPS {
 
     public double distanceTo(Location loc1, Location loc2) {
 
-        if (loc1.getWorld() != loc2.getWorld())
+        if (loc1.getLevel() != loc2.getLevel())
             return Double.MAX_VALUE;
 
         double deltaX = Math.abs(loc1.getX() - loc2.getX());
@@ -244,7 +231,7 @@ public class JPS {
             for (int x = -1; x <= 1; x++)
                 for (int z = -1; z <= 1; z++)
                     if (!(x == 0 && z == 0) && x * z == 0) {
-                        Location loc = new Location(Bukkit.getWorlds().get(0), location.getBlockX() + x, location.getBlockY(), location.getBlockZ() + z);
+                        Location loc = new Location(new Vec3(location.getBlockX() + x, location.getBlockY(), location.getBlockZ() + z), location.getLevel());
 
                         // usual unchanged y
                         if (canStandAt(loc))
@@ -281,10 +268,10 @@ public class JPS {
 
                         //ladder
                         if (canClimbLadders)
-                            if (loc.clone().add(-x, 0, -z).getBlock().getType() == Material.LADDER) {
+                            if (loc.clone().add(-x, 0, -z).isTheSameBlock(Blocks.LADDER)) {
                                 Location nLoc = loc.clone().add(-x, 0, -z);
                                 int up = 1;
-                                while (nLoc.clone().add(0, up, 0).getBlock().getType() == Material.LADDER)
+                                while (nLoc.clone().add(0, up, 0).isTheSameBlock(Blocks.LADDER))
                                     up++;
 
                                 reachNode(nLoc.clone().add(0, up, 0), expense + up * 2);
diff --git a/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/platform/Location.java b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/platform/Location.java
new file mode 100644
index 0000000000000000000000000000000000000000..34164f4b8ce232fdfcf32f04dbf7e34779cd1a6a
--- /dev/null
+++ b/src/main/java/nl/abelkrijgtalles/mojangmaps/pathfinding/platform/Location.java
@@ -0,0 +1,131 @@
+/*
+ * mojang_maps.pathfinding.main
+ * Copyright (C) 2024 Abel van Hulst/Abelkrijgtalles/Abelpro678
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package nl.abelkrijgtalles.mojangmaps.pathfinding.platform;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Position;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.Vec3;
+
+public class Location implements Cloneable {
+
+    private final Level level;
+    private Position position;
+
+    public Location(Position position, Level level) {
+
+        this.position = position;
+        this.level = level;
+    }
+
+    public Position getPosition() {
+
+        return position;
+    }
+
+    public Level getLevel() {
+
+        return level;
+    }
+
+    @Override
+    public Location clone() {
+
+        try {
+            return (Location) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    public Location add(double x, double y, double z) {
+
+        position = new Vec3(position.x(), position.y(), position.z()).add(x, y, z);
+        return this;
+
+    }
+
+    public double getX() {
+
+        return position.x();
+
+    }
+
+    public double getY() {
+
+        return position.y();
+
+    }
+
+    public double getZ() {
+
+        return position.z();
+
+    }
+
+    public int getBlockX() {
+
+        return (int) Math.floor(getX());
+
+    }
+
+    public int getBlockY() {
+
+        return (int) Math.floor(getY());
+
+    }
+
+    public int getBlockZ() {
+
+        return (int) Math.floor(getZ());
+
+    }
+
+    public Block getBlock() {
+
+        return level.getBlockState(new BlockPos(getBlockX(), getBlockY(), getBlockZ())).getBlock();
+
+    }
+
+    public BlockState getBLockState() {
+
+        return level.getBlockState(new BlockPos(getBlockX(), getBlockY(), getBlockZ()));
+
+    }
+
+    public boolean isTheSameBlock(Block block) {
+
+        return this.getBLockState().getBlock() == block;
+
+    }
+
+    public boolean isSolidBlock() {
+
+        return Block.isShapeFullBlock(this.getBLockState().getOcclusionShape(
+                #if MC_VER <= MC_1_21_0
+                level,
+                new BlockPos(getBlockX(), getBlockY(), getBlockZ())
+                #endif
+        ));
+
+    }
+
+}
